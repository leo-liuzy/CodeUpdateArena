{
    "api_path": "torch.Tensor.view",
    "arguments_str": "*shape",
    "doc_string": "view(*shape) -> Tensor\n\nReturns a new tensor with the same data as the :attr:`self` tensor but of a\ndifferent :attr:`shape`.\n\nThe returned tensor shares the same data and must have the same number\nof elements, but may have a different size. For a tensor to be viewed, the new\nview size must be compatible with its original size and stride, i.e., each new\nview dimension must either be a subspace of an original dimension, or only span\nacross original dimensions :math:`d, d+1, \\dots, d+k` that satisfy the following\ncontiguity-like condition that :math:`\\forall i = d, \\dots, d+k-1`,\n\n.. math::\n\n  \\text{stride}[i] = \\text{stride}[i+1] \\times \\text{size}[i+1]\n\nOtherwise, it will not be possible to view :attr:`self` tensor as :attr:`shape`\nwithout copying it (e.g., via :meth:`contiguous`). When it is unclear whether a\n:meth:`view` can be performed, it is advisable to use :meth:`reshape`, which\nreturns a view if the shapes are compatible, and copies (equivalent to calling\n:meth:`contiguous`) otherwise.\n\nArgs:\n    shape (torch.Size or int...): the desired size\n\nExample::\n\n    >>> x = torch.randn(4, 4)\n    >>> x.size()\n    torch.Size([4, 4])\n    >>> y = x.view(16)\n    >>> y.size()\n    torch.Size([16])\n    >>> z = x.view(-1, 8)  # the size -1 is inferred from other dimensions\n    >>> z.size()\n    torch.Size([2, 8])\n\n    >>> a = torch.randn(1, 2, 3, 4)\n    >>> a.size()\n    torch.Size([1, 2, 3, 4])\n    >>> b = a.transpose(1, 2)  # Swaps 2nd and 3rd dimension\n    >>> b.size()\n    torch.Size([1, 3, 2, 4])\n    >>> c = a.view(1, 3, 2, 4)  # Does not change tensor layout in memory\n    >>> c.size()\n    torch.Size([1, 3, 2, 4])\n    >>> torch.equal(b, c)\n    False\n\n\n.. method:: view(dtype) -> Tensor\n   :noindex:\n\nReturns a new tensor with the same data as the :attr:`self` tensor but of a\ndifferent :attr:`dtype`.\n\nIf the element size of :attr:`dtype` is different than that of ``self.dtype``,\nthen the size of the last dimension of the output will be scaled\nproportionally.  For instance, if :attr:`dtype` element size is twice that of\n``self.dtype``, then each pair of elements in the last dimension of\n:attr:`self` will be combined, and the size of the last dimension of the output\nwill be half that of :attr:`self`. If :attr:`dtype` element size is half that\nof ``self.dtype``, then each element in the last dimension of :attr:`self` will\nbe split in two, and the size of the last dimension of the output will be\ndouble that of :attr:`self`. For this to be possible, the following conditions\nmust be true:\n\n    * ``self.dim()`` must be greater than 0.\n    * ``self.stride(-1)`` must be 1.\n\nAdditionally, if the element size of :attr:`dtype` is greater than that of\n``self.dtype``, the following conditions must be true as well:\n\n    * ``self.size(-1)`` must be divisible by the ratio between the element\n      sizes of the dtypes.\n    * ``self.storage_offset()`` must be divisible by the ratio between the\n      element sizes of the dtypes.\n    * The strides of all dimensions, except the last dimension, must be\n      divisible by the ratio between the element sizes of the dtypes.\n\nIf any of the above conditions are not met, an error is thrown.\n\n.. warning::\n\n    This overload is not supported by TorchScript, and using it in a Torchscript\n    program will cause undefined behavior.\n\n\nArgs:\n    dtype (:class:`torch.dtype`): the desired dtype\n\nExample::\n\n    >>> x = torch.randn(4, 4)\n    >>> x\n    tensor([[ 0.9482, -0.0310,  1.4999, -0.5316],\n            [-0.1520,  0.7472,  0.5617, -0.8649],\n            [-2.4724, -0.0334, -0.2976, -0.8499],\n            [-0.2109,  1.9913, -0.9607, -0.6123]])\n    >>> x.dtype\n    torch.float32\n\n    >>> y = x.view(torch.int32)\n    >>> y\n    tensor([[ 1064483442, -1124191867,  1069546515, -1089989247],\n            [-1105482831,  1061112040,  1057999968, -1084397505],\n            [-1071760287, -1123489973, -1097310419, -1084649136],\n            [-1101533110,  1073668768, -1082790149, -1088634448]],\n        dtype=torch.int32)\n    >>> y[0, 0] = 1000000000\n    >>> x\n    tensor([[ 0.0047, -0.0310,  1.4999, -0.5316],\n            [-0.1520,  0.7472,  0.5617, -0.8649],\n            [-2.4724, -0.0334, -0.2976, -0.8499],\n            [-0.2109,  1.9913, -0.9607, -0.6123]])\n\n    >>> x.view(torch.cfloat)\n    tensor([[ 0.0047-0.0310j,  1.4999-0.5316j],\n            [-0.1520+0.7472j,  0.5617-0.8649j],\n            [-2.4724-0.0334j, -0.2976-0.8499j],\n            [-0.2109+1.9913j, -0.9607-0.6123j]])\n    >>> x.view(torch.cfloat).size()\n    torch.Size([4, 2])\n\n    >>> x.view(torch.uint8)\n    tensor([[  0, 202, 154,  59, 182, 243, 253, 188, 185, 252, 191,  63, 240,  22,\n               8, 191],\n            [227, 165,  27, 190, 128,  72,  63,  63, 146, 203,  15,  63,  22, 106,\n              93, 191],\n            [205,  59,  30, 192, 112, 206,   8, 189,   7,  95, 152, 190,  12, 147,\n              89, 191],\n            [ 43, 246,  87, 190, 235, 226, 254,  63, 111, 240, 117, 191, 177, 191,\n              28, 191]], dtype=torch.uint8)\n    >>> x.view(torch.uint8).size()\n    torch.Size([4, 16])",
    "imports": [
        "import torch"
    ],
    "return_type_hint": "-> Tensor",
    "source_code": null,
    "summarized_doc": "Function Name: view(*shape) -> Tensor\n\nDescription: \nReturns a new tensor with the same data as the original tensor but with the specified shape. The function returns a new tensor that shares the same data and must have the same number of elements as the original tensor. However, while the elements are the same, the size and shape of the tensor may differ. To be viewed, the new tensor size must comply with the original size and stride. \n\nInput:\n- shape (torch.Size or int...): The desired size for the new tensor. \n\nOutput: \nA new Tensor with the same data as the 'self' Tensor but of a different shape.\n\nExample:\n```python\nx = torch.randn(4, 4)\ny = x.view(16)\nz = x.view(-1, 8)\n```\n\nFunction Name: view(dtype) -> Tensor\n\nDescription: \nReturns a new tensor with the same data as the original tensor but with the specified data type. The element size of the specified data type must be different from that of the old data type, and the size of the output dimension will be scaled accordingly. Certain conditions must also be true in order to view the new tensor, if not an error will be thrown.\n\nInput: \n- dtype (:class:`torch.dtype`): A specific data type that you want for the new tensor.\n\nWarning: This overload is not supported by TorchScript, and using it in a TorchScript program will cause undefined behavior.\n\nOutput: \nA new Tensor with the same data as the 'self' Tensor but of a different dtype.\n\nExample:\n```python\nx = torch.randn(4, 4)\ny = x.view(torch.int32)\n```\n"
}