{
    "api_path": "numpy.diag",
    "arguments_str": "v,k=0",
    "doc_string": "Extract a diagonal or construct a diagonal array.\n\nSee the more detailed documentation for ``numpy.diagonal`` if you use this\nfunction to extract a diagonal and wish to write to the resulting array;\nwhether it returns a copy or a view depends on what version of numpy you\nare using.\n\nParameters\n----------\nv : array_like\n    If `v` is a 2-D array, return a copy of its `k`-th diagonal.\n    If `v` is a 1-D array, return a 2-D array with `v` on the `k`-th\n    diagonal.\nk : int, optional\n    Diagonal in question. The default is 0. Use `k>0` for diagonals\n    above the main diagonal, and `k<0` for diagonals below the main\n    diagonal.\n\nReturns\n-------\nout : ndarray\n    The extracted diagonal or constructed diagonal array.\n\nSee Also\n--------\ndiagonal : Return specified diagonals.\ndiagflat : Create a 2-D array with the flattened input as a diagonal.\ntrace : Sum along diagonals.\ntriu : Upper triangle of an array.\ntril : Lower triangle of an array.\n\nExamples\n--------\n>>> x = np.arange(9).reshape((3,3))\n>>> x\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])\n\n>>> np.diag(x)\narray([0, 4, 8])\n>>> np.diag(x, k=1)\narray([1, 5])\n>>> np.diag(x, k=-1)\narray([3, 7])\n\n>>> np.diag(np.diag(x))\narray([[0, 0, 0],\n       [0, 4, 0],\n       [0, 0, 8]])",
    "imports": [
        "import numpy"
    ],
    "return_type_hint": "",
    "source_code": "@array_function_dispatch(_diag_dispatcher)\ndef diag(v, k=0):\n    \"\"\"\n    Extract a diagonal or construct a diagonal array.\n\n    See the more detailed documentation for ``numpy.diagonal`` if you use this\n    function to extract a diagonal and wish to write to the resulting array;\n    whether it returns a copy or a view depends on what version of numpy you\n    are using.\n\n    Parameters\n    ----------\n    v : array_like\n        If `v` is a 2-D array, return a copy of its `k`-th diagonal.\n        If `v` is a 1-D array, return a 2-D array with `v` on the `k`-th\n        diagonal.\n    k : int, optional\n        Diagonal in question. The default is 0. Use `k>0` for diagonals\n        above the main diagonal, and `k<0` for diagonals below the main\n        diagonal.\n\n    Returns\n    -------\n    out : ndarray\n        The extracted diagonal or constructed diagonal array.\n\n    See Also\n    --------\n    diagonal : Return specified diagonals.\n    diagflat : Create a 2-D array with the flattened input as a diagonal.\n    trace : Sum along diagonals.\n    triu : Upper triangle of an array.\n    tril : Lower triangle of an array.\n\n    Examples\n    --------\n    >>> x = np.arange(9).reshape((3,3))\n    >>> x\n    array([[0, 1, 2],\n           [3, 4, 5],\n           [6, 7, 8]])\n\n    >>> np.diag(x)\n    array([0, 4, 8])\n    >>> np.diag(x, k=1)\n    array([1, 5])\n    >>> np.diag(x, k=-1)\n    array([3, 7])\n\n    >>> np.diag(np.diag(x))\n    array([[0, 0, 0],\n           [0, 4, 0],\n           [0, 0, 8]])\n\n    \"\"\"\n    v = asanyarray(v)\n    s = v.shape\n    if len(s) == 1:\n        n = s[0]+abs(k)\n        res = zeros((n, n), v.dtype)\n        if k >= 0:\n            i = k\n        else:\n            i = (-k) * n\n        res[:n-k].flat[i::n+1] = v\n        return res\n    elif len(s) == 2:\n        return diagonal(v, k)\n    else:\n        raise ValueError(\"Input must be 1- or 2-d.\")\n",
    "summarized_doc": "This is a function for extracting a diagonal or constructing a diagonal array from a given input array. \n\nIt has two parameters:\n1. `v` (required): This is an array-like input. If it is a 2-D array, the function will return a copy of its `k`-th diagonal. If it is a 1-D array, it will return a 2-D array with `v` on the `k`-th diagonal.\n2. `k` (optional): This integer parameter decides which diagonal should be considered. The default value is 0. Use `k>0` for diagonals above the main diagonal, and `k<0` for diagonals below the main diagonal.\n\nThe function returns an ndarray which is either the extracted diagonal or constructed diagonal array.\n\nHere are examples showing how to use it:\n\n```python\nimport numpy as np\nx = np.arange(9).reshape((3,3))\nprint(np.diag(x))\nprint(np.diag(x, k=1))\nprint(np.diag(x, k=-1))\nprint(np.diag(np.diag(x)))\n```\n\nThis will output:\n```python\narray([0, 4, 8])\narray([1, 5])\narray([3, 7])\narray([[0, 0, 0], [0, 4, 0], [0, 0, 8]])\n```\nThis function could be related to others like `diagonal`, `diagflat`, `trace`, `triu`, `tril` which all deal with operations on array diagonals in different forms.\n\nNote: It's important to see the more detailed documentation for `numpy.diagonal` if you aim to modify the resulting array. The behavior differs between numpy versions - it might return a copy or a view."
}