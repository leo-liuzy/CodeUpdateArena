{
    "api_path": "sympy.factor",
    "arguments_str": "f,*gens,deep=False,**args",
    "doc_string": "Compute the factorization of expression, ``f``, into irreducibles. (To\nfactor an integer into primes, use ``factorint``.)\n\nThere two modes implemented: symbolic and formal. If ``f`` is not an\ninstance of :class:`Poly` and generators are not specified, then the\nformer mode is used. Otherwise, the formal mode is used.\n\nIn symbolic mode, :func:`factor` will traverse the expression tree and\nfactor its components without any prior expansion, unless an instance\nof :class:`~.Add` is encountered (in this case formal factorization is\nused). This way :func:`factor` can handle large or symbolic exponents.\n\nBy default, the factorization is computed over the rationals. To factor\nover other domain, e.g. an algebraic or finite field, use appropriate\noptions: ``extension``, ``modulus`` or ``domain``.\n\nExamples\n========\n\n>>> from sympy import factor, sqrt, exp\n>>> from sympy.abc import x, y\n\n>>> factor(2*x**5 + 2*x**4*y + 4*x**3 + 4*x**2*y + 2*x + 2*y)\n2*(x + y)*(x**2 + 1)**2\n\n>>> factor(x**2 + 1)\nx**2 + 1\n>>> factor(x**2 + 1, modulus=2)\n(x + 1)**2\n>>> factor(x**2 + 1, gaussian=True)\n(x - I)*(x + I)\n\n>>> factor(x**2 - 2, extension=sqrt(2))\n(x - sqrt(2))*(x + sqrt(2))\n\n>>> factor((x**2 - 1)/(x**2 + 4*x + 4))\n(x - 1)*(x + 1)/(x + 2)**2\n>>> factor((x**2 + 4*x + 4)**10000000*(x**2 + 1))\n(x + 2)**20000000*(x**2 + 1)\n\nBy default, factor deals with an expression as a whole:\n\n>>> eq = 2**(x**2 + 2*x + 1)\n>>> factor(eq)\n2**(x**2 + 2*x + 1)\n\nIf the ``deep`` flag is True then subexpressions will\nbe factored:\n\n>>> factor(eq, deep=True)\n2**((x + 1)**2)\n\nIf the ``fraction`` flag is False then rational expressions\nwill not be combined. By default it is True.\n\n>>> factor(5*x + 3*exp(2 - 7*x), deep=True)\n(5*x*exp(7*x) + 3*exp(2))*exp(-7*x)\n>>> factor(5*x + 3*exp(2 - 7*x), deep=True, fraction=False)\n5*x + 3*exp(2)*exp(-7*x)\n\nSee Also\n========\nsympy.ntheory.factor_.factorint",
    "imports": [
        "import sympy"
    ],
    "return_type_hint": "",
    "source_code": "@public\ndef factor(f, *gens, deep=False, **args):\n    \"\"\"\n    Compute the factorization of expression, ``f``, into irreducibles. (To\n    factor an integer into primes, use ``factorint``.)\n\n    There two modes implemented: symbolic and formal. If ``f`` is not an\n    instance of :class:`Poly` and generators are not specified, then the\n    former mode is used. Otherwise, the formal mode is used.\n\n    In symbolic mode, :func:`factor` will traverse the expression tree and\n    factor its components without any prior expansion, unless an instance\n    of :class:`~.Add` is encountered (in this case formal factorization is\n    used). This way :func:`factor` can handle large or symbolic exponents.\n\n    By default, the factorization is computed over the rationals. To factor\n    over other domain, e.g. an algebraic or finite field, use appropriate\n    options: ``extension``, ``modulus`` or ``domain``.\n\n    Examples\n    ========\n\n    >>> from sympy import factor, sqrt, exp\n    >>> from sympy.abc import x, y\n\n    >>> factor(2*x**5 + 2*x**4*y + 4*x**3 + 4*x**2*y + 2*x + 2*y)\n    2*(x + y)*(x**2 + 1)**2\n\n    >>> factor(x**2 + 1)\n    x**2 + 1\n    >>> factor(x**2 + 1, modulus=2)\n    (x + 1)**2\n    >>> factor(x**2 + 1, gaussian=True)\n    (x - I)*(x + I)\n\n    >>> factor(x**2 - 2, extension=sqrt(2))\n    (x - sqrt(2))*(x + sqrt(2))\n\n    >>> factor((x**2 - 1)/(x**2 + 4*x + 4))\n    (x - 1)*(x + 1)/(x + 2)**2\n    >>> factor((x**2 + 4*x + 4)**10000000*(x**2 + 1))\n    (x + 2)**20000000*(x**2 + 1)\n\n    By default, factor deals with an expression as a whole:\n\n    >>> eq = 2**(x**2 + 2*x + 1)\n    >>> factor(eq)\n    2**(x**2 + 2*x + 1)\n\n    If the ``deep`` flag is True then subexpressions will\n    be factored:\n\n    >>> factor(eq, deep=True)\n    2**((x + 1)**2)\n\n    If the ``fraction`` flag is False then rational expressions\n    will not be combined. By default it is True.\n\n    >>> factor(5*x + 3*exp(2 - 7*x), deep=True)\n    (5*x*exp(7*x) + 3*exp(2))*exp(-7*x)\n    >>> factor(5*x + 3*exp(2 - 7*x), deep=True, fraction=False)\n    5*x + 3*exp(2)*exp(-7*x)\n\n    See Also\n    ========\n    sympy.ntheory.factor_.factorint\n\n    \"\"\"\n    f = sympify(f)\n    if deep:\n        def _try_factor(expr):\n            \"\"\"\n            Factor, but avoid changing the expression when unable to.\n            \"\"\"\n            fac = factor(expr, *gens, **args)\n            if fac.is_Mul or fac.is_Pow:\n                return fac\n            return expr\n\n        f = bottom_up(f, _try_factor)\n        # clean up any subexpressions that may have been expanded\n        # while factoring out a larger expression\n        partials = {}\n        muladd = f.atoms(Mul, Add)\n        for p in muladd:\n            fac = factor(p, *gens, **args)\n            if (fac.is_Mul or fac.is_Pow) and fac != p:\n                partials[p] = fac\n        return f.xreplace(partials)\n\n    try:\n        return _generic_factor(f, gens, args, method='factor')\n    except PolynomialError as msg:\n        if not f.is_commutative:\n            return factor_nc(f)\n        else:\n            raise PolynomialError(msg)\n",
    "summarized_doc": "The functionality of this method is to compute the factorization of a given expression `f` into its irreducible components. If the goal is to factor an integer into primes, the `factorint` function should be used instead.\n\nThis function implements two modes: symbolic and formal. The symbolic is used if the input `f` is not an instance of the `Poly` class and no generators are specified. If either of these conditions are not met, the formal mode is used.\n\nWhen in symbolic mode, the function will traverse the expression tree and factor its components without any prior expansion, except when an instance of `Add` class is encountered and then formal factorization is applied. This allows the function to handle large or symbolic exponents.\n\nBy default, factorization is computed over the rationals. To factor over other domains, such as algebraic or finite fields, use the appropriate options: `extension`, `modulus`, or `domain`.\n\nThe method has certain flags for special operations: 'deep' and 'fraction'. 'deep' (default False) dictates whether subexpressions should be factored or not. 'fraction' (default True) determines whether rational expressions should be combined or not.\n\nInput Parameters:\n1. `f`: The expression to be factored. \n2. `*gens`: Generators.\n3. `**flags`: Optional arguments.\n   - `extension`: Indicates the algebraic extension.\n   - `modulus`: Represents the modulus.\n   - `domain`: Specifies the domain over which factorization should be performed.\n   - `deep`: Boolean, if True the subexpressions will be factored.\n   - `fraction`: Boolean, when False rational expressions will not be combined.\n\nOutput: Returns a factored form of the given expression.\n\nExample of usage:\n```python\nfrom sympy import factor, sqrt\nfrom sympy.abc import x, y\n\nfactor_x = factor(2*x**5 + 2*x**4*y + 4*x**3 + 4*x**2*y + 2*x + 2*y)\nprint(factor_x)  # output: 2*(x + y)*(x**2 + 1)**2\n```\n\nRefer to sympy.ntheory.factor_.factorint for more details."
}