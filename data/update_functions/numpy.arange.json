{
    "api_path": "numpy.arange",
    "arguments_str": "[start,]stop[,step,],dtype=None,*,like=None",
    "doc_string": "arange([start,] stop[, step,], dtype=None, *, like=None)\n\nReturn evenly spaced values within a given interval.\n\n``arange`` can be called with a varying number of positional arguments:\n\n* ``arange(stop)``: Values are generated within the half-open interval\n  ``[0, stop)`` (in other words, the interval including `start` but\n  excluding `stop`).\n* ``arange(start, stop)``: Values are generated within the half-open\n  interval ``[start, stop)``.\n* ``arange(start, stop, step)`` Values are generated within the half-open\n  interval ``[start, stop)``, with spacing between values given by\n  ``step``.\n\nFor integer arguments the function is roughly equivalent to the Python\nbuilt-in :py:class:`range`, but returns an ndarray rather than a ``range``\ninstance.\n\nWhen using a non-integer step, such as 0.1, it is often better to use\n`numpy.linspace`.\n\nSee the Warning sections below for more information.\n\nParameters\n----------\nstart : integer or real, optional\n    Start of interval.  The interval includes this value.  The default\n    start value is 0.\nstop : integer or real\n    End of interval.  The interval does not include this value, except\n    in some cases where `step` is not an integer and floating point\n    round-off affects the length of `out`.\nstep : integer or real, optional\n    Spacing between values.  For any output `out`, this is the distance\n    between two adjacent values, ``out[i+1] - out[i]``.  The default\n    step size is 1.  If `step` is specified as a position argument,\n    `start` must also be given.\ndtype : dtype, optional\n    The type of the output array.  If `dtype` is not given, infer the data\n    type from the other input arguments.\nlike : array_like, optional\n    Reference object to allow the creation of arrays which are not\n    NumPy arrays. If an array-like passed in as ``like`` supports\n    the ``__array_function__`` protocol, the result will be defined\n    by it. In this case, it ensures the creation of an array object\n    compatible with that passed in via this argument.\n\n    .. versionadded:: 1.20.0\n\nReturns\n-------\narange : ndarray\n    Array of evenly spaced values.\n\n    For floating point arguments, the length of the result is\n    ``ceil((stop - start)/step)``.  Because of floating point overflow,\n    this rule may result in the last element of `out` being greater\n    than `stop`.\n\nWarnings\n--------\nThe length of the output might not be numerically stable.\n\nAnother stability issue is due to the internal implementation of\n`numpy.arange`.\nThe actual step value used to populate the array is\n``dtype(start + step) - dtype(start)`` and not `step`. Precision loss\ncan occur here, due to casting or due to using floating points when\n`start` is much larger than `step`. This can lead to unexpected\nbehaviour. For example::\n\n  >>> np.arange(0, 5, 0.5, dtype=int)\n  array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n  >>> np.arange(-3, 3, 0.5, dtype=int)\n  array([-3, -2, -1,  0,  1,  2,  3,  4,  5,  6,  7,  8])\n\nIn such cases, the use of `numpy.linspace` should be preferred.\n\nThe built-in :py:class:`range` generates :std:doc:`Python built-in integers\nthat have arbitrary size <python:c-api/long>`, while `numpy.arange`\nproduces `numpy.int32` or `numpy.int64` numbers. This may result in\nincorrect results for large integer values::\n\n  >>> power = 40\n  >>> modulo = 10000\n  >>> x1 = [(n ** power) % modulo for n in range(8)]\n  >>> x2 = [(n ** power) % modulo for n in np.arange(8)]\n  >>> print(x1)\n  [0, 1, 7776, 8801, 6176, 625, 6576, 4001]  # correct\n  >>> print(x2)\n  [0, 1, 7776, 7185, 0, 5969, 4816, 3361]  # incorrect\n\nSee Also\n--------\nnumpy.linspace : Evenly spaced numbers with careful handling of endpoints.\nnumpy.ogrid: Arrays of evenly spaced numbers in N-dimensions.\nnumpy.mgrid: Grid-shaped arrays of evenly spaced numbers in N-dimensions.\n:ref:`how-to-partition`\n\nExamples\n--------\n>>> np.arange(3)\narray([0, 1, 2])\n>>> np.arange(3.0)\narray([ 0.,  1.,  2.])\n>>> np.arange(3,7)\narray([3, 4, 5, 6])\n>>> np.arange(3,7,2)\narray([3, 5])",
    "imports": [
        "import numpy"
    ],
    "return_type_hint": "",
    "source_code": null,
    "summarized_doc": "The `arange` function in the Python library, NumPy, generates evenly spaced values within a given interval. It has varying number of positional arguments: stop, start-stop, or start-stop-step. When used with integer arguments, it behaves similarly to the Python built-in `range` function. If the step value provided is a non-integer, it would be better to use `numpy.linspace`.\n\nThe parameters for this function are:\n1. `start`: This is the start of the interval. It is included in the interval. It can be an integer or a real number and its default value is 0.\n2. `stop`: This is the end of the interval, it excludes this value. It can be an integer or a real number.\n3. `step`: This is the spacing between values and can be integer or real. By default, it is 1.\n4. `dtype`: This is an optional parameter that specifies the type of the output array. If not given, it'll infer from other input arguments.\n5. `like`: This is an optional parameter which allows the creation of arrays that are not necessarily NumPy arrays.\n\nThe function returns an ndarray, which is an array of evenly spaced values. \n\nA precautionary warning mentioned in the documentation is about the length of the output which might not be numerically stable due to issues in the internal implementation of `numpy.arange`.\n\nExample usage of the function are as follows:\n```\n>>> np.arange(3)\narray([0, 1, 2])\n>>> np.arange(3.0)\narray([ 0.,  1.,  2.])\n>>> np.arange(3,7)\narray([3, 4, 5, 6])\n>>> np.arange(3,7,2)\narray([3, 5])\n```\nHere, we can see that np.arange can produce integer or floating point values and also cater different intervals and step sizes."
}