{
    "api_path": "sympy.symbols",
    "arguments_str": "names,*,cls=Symbol,**args",
    "doc_string": "Transform strings into instances of :class:`Symbol` class.\n\n:func:`symbols` function returns a sequence of symbols with names taken\nfrom ``names`` argument, which can be a comma or whitespace delimited\nstring, or a sequence of strings::\n\n    >>> from sympy import symbols, Function\n\n    >>> x, y, z = symbols('x,y,z')\n    >>> a, b, c = symbols('a b c')\n\nThe type of output is dependent on the properties of input arguments::\n\n    >>> symbols('x')\n    x\n    >>> symbols('x,')\n    (x,)\n    >>> symbols('x,y')\n    (x, y)\n    >>> symbols(('a', 'b', 'c'))\n    (a, b, c)\n    >>> symbols(['a', 'b', 'c'])\n    [a, b, c]\n    >>> symbols({'a', 'b', 'c'})\n    {a, b, c}\n\nIf an iterable container is needed for a single symbol, set the ``seq``\nargument to ``True`` or terminate the symbol name with a comma::\n\n    >>> symbols('x', seq=True)\n    (x,)\n\nTo reduce typing, range syntax is supported to create indexed symbols.\nRanges are indicated by a colon and the type of range is determined by\nthe character to the right of the colon. If the character is a digit\nthen all contiguous digits to the left are taken as the nonnegative\nstarting value (or 0 if there is no digit left of the colon) and all\ncontiguous digits to the right are taken as 1 greater than the ending\nvalue::\n\n    >>> symbols('x:10')\n    (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)\n\n    >>> symbols('x5:10')\n    (x5, x6, x7, x8, x9)\n    >>> symbols('x5(:2)')\n    (x50, x51)\n\n    >>> symbols('x5:10,y:5')\n    (x5, x6, x7, x8, x9, y0, y1, y2, y3, y4)\n\n    >>> symbols(('x5:10', 'y:5'))\n    ((x5, x6, x7, x8, x9), (y0, y1, y2, y3, y4))\n\nIf the character to the right of the colon is a letter, then the single\nletter to the left (or 'a' if there is none) is taken as the start\nand all characters in the lexicographic range *through* the letter to\nthe right are used as the range::\n\n    >>> symbols('x:z')\n    (x, y, z)\n    >>> symbols('x:c')  # null range\n    ()\n    >>> symbols('x(:c)')\n    (xa, xb, xc)\n\n    >>> symbols(':c')\n    (a, b, c)\n\n    >>> symbols('a:d, x:z')\n    (a, b, c, d, x, y, z)\n\n    >>> symbols(('a:d', 'x:z'))\n    ((a, b, c, d), (x, y, z))\n\nMultiple ranges are supported; contiguous numerical ranges should be\nseparated by parentheses to disambiguate the ending number of one\nrange from the starting number of the next::\n\n    >>> symbols('x:2(1:3)')\n    (x01, x02, x11, x12)\n    >>> symbols(':3:2')  # parsing is from left to right\n    (00, 01, 10, 11, 20, 21)\n\nOnly one pair of parentheses surrounding ranges are removed, so to\ninclude parentheses around ranges, double them. And to include spaces,\ncommas, or colons, escape them with a backslash::\n\n    >>> symbols('x((a:b))')\n    (x(a), x(b))\n    >>> symbols(r'x(:1\\,:2)')  # or r'x((:1)\\,(:2))'\n    (x(0,0), x(0,1))\n\nAll newly created symbols have assumptions set according to ``args``::\n\n    >>> a = symbols('a', integer=True)\n    >>> a.is_integer\n    True\n\n    >>> x, y, z = symbols('x,y,z', real=True)\n    >>> x.is_real and y.is_real and z.is_real\n    True\n\nDespite its name, :func:`symbols` can create symbol-like objects like\ninstances of Function or Wild classes. To achieve this, set ``cls``\nkeyword argument to the desired type::\n\n    >>> symbols('f,g,h', cls=Function)\n    (f, g, h)\n\n    >>> type(_[0])\n    <class 'sympy.core.function.UndefinedFunction'>",
    "imports": [
        "import sympy"
    ],
    "return_type_hint": "-> Any",
    "source_code": "def symbols(names, *, cls=Symbol, **args) -> Any:\n    r\"\"\"\n    Transform strings into instances of :class:`Symbol` class.\n\n    :func:`symbols` function returns a sequence of symbols with names taken\n    from ``names`` argument, which can be a comma or whitespace delimited\n    string, or a sequence of strings::\n\n        >>> from sympy import symbols, Function\n\n        >>> x, y, z = symbols('x,y,z')\n        >>> a, b, c = symbols('a b c')\n\n    The type of output is dependent on the properties of input arguments::\n\n        >>> symbols('x')\n        x\n        >>> symbols('x,')\n        (x,)\n        >>> symbols('x,y')\n        (x, y)\n        >>> symbols(('a', 'b', 'c'))\n        (a, b, c)\n        >>> symbols(['a', 'b', 'c'])\n        [a, b, c]\n        >>> symbols({'a', 'b', 'c'})\n        {a, b, c}\n\n    If an iterable container is needed for a single symbol, set the ``seq``\n    argument to ``True`` or terminate the symbol name with a comma::\n\n        >>> symbols('x', seq=True)\n        (x,)\n\n    To reduce typing, range syntax is supported to create indexed symbols.\n    Ranges are indicated by a colon and the type of range is determined by\n    the character to the right of the colon. If the character is a digit\n    then all contiguous digits to the left are taken as the nonnegative\n    starting value (or 0 if there is no digit left of the colon) and all\n    contiguous digits to the right are taken as 1 greater than the ending\n    value::\n\n        >>> symbols('x:10')\n        (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)\n\n        >>> symbols('x5:10')\n        (x5, x6, x7, x8, x9)\n        >>> symbols('x5(:2)')\n        (x50, x51)\n\n        >>> symbols('x5:10,y:5')\n        (x5, x6, x7, x8, x9, y0, y1, y2, y3, y4)\n\n        >>> symbols(('x5:10', 'y:5'))\n        ((x5, x6, x7, x8, x9), (y0, y1, y2, y3, y4))\n\n    If the character to the right of the colon is a letter, then the single\n    letter to the left (or 'a' if there is none) is taken as the start\n    and all characters in the lexicographic range *through* the letter to\n    the right are used as the range::\n\n        >>> symbols('x:z')\n        (x, y, z)\n        >>> symbols('x:c')  # null range\n        ()\n        >>> symbols('x(:c)')\n        (xa, xb, xc)\n\n        >>> symbols(':c')\n        (a, b, c)\n\n        >>> symbols('a:d, x:z')\n        (a, b, c, d, x, y, z)\n\n        >>> symbols(('a:d', 'x:z'))\n        ((a, b, c, d), (x, y, z))\n\n    Multiple ranges are supported; contiguous numerical ranges should be\n    separated by parentheses to disambiguate the ending number of one\n    range from the starting number of the next::\n\n        >>> symbols('x:2(1:3)')\n        (x01, x02, x11, x12)\n        >>> symbols(':3:2')  # parsing is from left to right\n        (00, 01, 10, 11, 20, 21)\n\n    Only one pair of parentheses surrounding ranges are removed, so to\n    include parentheses around ranges, double them. And to include spaces,\n    commas, or colons, escape them with a backslash::\n\n        >>> symbols('x((a:b))')\n        (x(a), x(b))\n        >>> symbols(r'x(:1\\,:2)')  # or r'x((:1)\\,(:2))'\n        (x(0,0), x(0,1))\n\n    All newly created symbols have assumptions set according to ``args``::\n\n        >>> a = symbols('a', integer=True)\n        >>> a.is_integer\n        True\n\n        >>> x, y, z = symbols('x,y,z', real=True)\n        >>> x.is_real and y.is_real and z.is_real\n        True\n\n    Despite its name, :func:`symbols` can create symbol-like objects like\n    instances of Function or Wild classes. To achieve this, set ``cls``\n    keyword argument to the desired type::\n\n        >>> symbols('f,g,h', cls=Function)\n        (f, g, h)\n\n        >>> type(_[0])\n        <class 'sympy.core.function.UndefinedFunction'>\n\n    \"\"\"\n    result = []\n\n    if isinstance(names, str):\n        marker = 0\n        splitters = r'\\,', r'\\:', r'\\ '\n        literals: list[tuple[str, str]] = []\n        for splitter in splitters:\n            if splitter in names:\n                while chr(marker) in names:\n                    marker += 1\n                lit_char = chr(marker)\n                marker += 1\n                names = names.replace(splitter, lit_char)\n                literals.append((lit_char, splitter[1:]))\n        def literal(s):\n            if literals:\n                for c, l in literals:\n                    s = s.replace(c, l)\n            return s\n\n        names = names.strip()\n        as_seq = names.endswith(',')\n        if as_seq:\n            names = names[:-1].rstrip()\n        if not names:\n            raise ValueError('no symbols given')\n\n        # split on commas\n        names = [n.strip() for n in names.split(',')]\n        if not all(n for n in names):\n            raise ValueError('missing symbol between commas')\n        # split on spaces\n        for i in range(len(names) - 1, -1, -1):\n            names[i: i + 1] = names[i].split()\n\n        seq = args.pop('seq', as_seq)\n\n        for name in names:\n            if not name:\n                raise ValueError('missing symbol')\n\n            if ':' not in name:\n                symbol = cls(literal(name), **args)\n                result.append(symbol)\n                continue\n\n            split: list[str] = _range.split(name)\n            split_list: list[list[str]] = []\n            # remove 1 layer of bounding parentheses around ranges\n            for i in range(len(split) - 1):\n                if i and ':' in split[i] and split[i] != ':' and \\\n                        split[i - 1].endswith('(') and \\\n                        split[i + 1].startswith(')'):\n                    split[i - 1] = split[i - 1][:-1]\n                    split[i + 1] = split[i + 1][1:]\n            for s in split:\n                if ':' in s:\n                    if s.endswith(':'):\n                        raise ValueError('missing end range')\n                    a, b = s.split(':')\n                    if b[-1] in string.digits:\n                        a_i = 0 if not a else int(a)\n                        b_i = int(b)\n                        split_list.append([str(c) for c in range(a_i, b_i)])\n                    else:\n                        a = a or 'a'\n                        split_list.append([string.ascii_letters[c] for c in range(\n                            string.ascii_letters.index(a),\n                            string.ascii_letters.index(b) + 1)])  # inclusive\n                    if not split_list[-1]:\n                        break\n                else:\n                    split_list.append([s])\n            else:\n                seq = True\n                if len(split_list) == 1:\n                    names = split_list[0]\n                else:\n                    names = [''.join(s) for s in product(*split_list)]\n                if literals:\n                    result.extend([cls(literal(s), **args) for s in names])\n                else:\n                    result.extend([cls(s, **args) for s in names])\n\n        if not seq and len(result) <= 1:\n            if not result:\n                return ()\n            return result[0]\n\n        return tuple(result)\n    else:\n        for name in names:\n            result.append(symbols(name, cls=cls, **args))\n\n        return type(names)(result)\n",
    "summarized_doc": "The `symbols` function in the sympy library is used to transform strings into instances of the Symbol class. This function takes in a `names` argument, which can be comma or whitespace-delimited string, or a sequence of strings. The output type is dependent on the properties of these input arguments. \n\nHere are some examples of how to use `symbols` function:\n```Python\nfrom sympy import symbols, Function\nx, y, z = symbols('x,y,z')\na, b, c = symbols('a b c')\n```\n\nThe following examples further illustrate how output can change based on input:\n\n```Python\nsymbols('x') # returns x\nsymbols('x,') # returns (x,)\nsymbols('x,y') # returns (x, y)\nsymbols(('a', 'b', 'c')) # returns (a, b, c)\nsymbols(['a', 'b', 'c']) # returns [a, b, c]\nsymbols({'a', 'b', 'c'}) # returns {a, b, c}\n```\n\nFor a container output for a single symbol, `seq` can be set to True or the symbol name can be terminated with a comma.\n```Python\nsymbols('x', seq=True) # returns (x,)\n```\n\nThis function also supports range syntax to create indexed symbols, with ranges indicated by a colon. The range type is determined by the character to the right of the colon.\n\nThe `symbols` function also adheres to defined assumptions set according to the `args` parameter. If the input string is associated with specific properties, returned symbols will also inherit those properties. \n```Python\na = symbols('a', integer=True)\nx, y, z = symbols('x,y,z', real=True)\n```\n\nDespite its name, the `symbols` function can also create symbol-like objects like instances of the Function or Wild classes by setting the `cls` keyword to the desired type.\n```Python\nsymbols('f,g,h', cls=Function)\n```"
}