{
    "api_path": "pandas.DataFrame.eq",
    "arguments_str": "self,other,axis:Axis=\"columns\",level=None",
    "doc_string": "Get Equal to of dataframe and other, element-wise (binary operator `eq`).\n\nAmong flexible wrappers (`eq`, `ne`, `le`, `lt`, `ge`, `gt`) to comparison\noperators.\n\nEquivalent to `==`, `!=`, `<=`, `<`, `>=`, `>` with support to choose axis\n(rows or columns) and level for comparison.\n\nParameters\n----------\nother : scalar, sequence, Series, or DataFrame\n    Any single or multiple element data structure, or list-like object.\naxis : {0 or 'index', 1 or 'columns'}, default 'columns'\n    Whether to compare by the index (0 or 'index') or columns\n    (1 or 'columns').\nlevel : int or label\n    Broadcast across a level, matching Index values on the passed\n    MultiIndex level.\n\nReturns\n-------\nDataFrame of bool\n    Result of the comparison.\n\nSee Also\n--------\nDataFrame.eq : Compare DataFrames for equality elementwise.\nDataFrame.ne : Compare DataFrames for inequality elementwise.\nDataFrame.le : Compare DataFrames for less than inequality\n    or equality elementwise.\nDataFrame.lt : Compare DataFrames for strictly less than\n    inequality elementwise.\nDataFrame.ge : Compare DataFrames for greater than inequality\n    or equality elementwise.\nDataFrame.gt : Compare DataFrames for strictly greater than\n    inequality elementwise.\n\nNotes\n-----\nMismatched indices will be unioned together.\n`NaN` values are considered different (i.e. `NaN` != `NaN`).\n\nExamples\n--------\n>>> df = pd.DataFrame({'cost': [250, 150, 100],\n...                    'revenue': [100, 250, 300]},\n...                   index=['A', 'B', 'C'])\n>>> df\n   cost  revenue\nA   250      100\nB   150      250\nC   100      300\n\nComparison with a scalar, using either the operator or method:\n\n>>> df == 100\n    cost  revenue\nA  False     True\nB  False    False\nC   True    False\n\n>>> df.eq(100)\n    cost  revenue\nA  False     True\nB  False    False\nC   True    False\n\nWhen `other` is a :class:`Series`, the columns of a DataFrame are aligned\nwith the index of `other` and broadcast:\n\n>>> df != pd.Series([100, 250], index=[\"cost\", \"revenue\"])\n    cost  revenue\nA   True     True\nB   True    False\nC  False     True\n\nUse the method to control the broadcast axis:\n\n>>> df.ne(pd.Series([100, 300], index=[\"A\", \"D\"]), axis='index')\n   cost  revenue\nA  True    False\nB  True     True\nC  True     True\nD  True     True\n\nWhen comparing to an arbitrary sequence, the number of columns must\nmatch the number elements in `other`:\n\n>>> df == [250, 100]\n    cost  revenue\nA   True     True\nB  False    False\nC  False    False\n\nUse the method to control the axis:\n\n>>> df.eq([250, 250, 100], axis='index')\n    cost  revenue\nA   True    False\nB  False     True\nC   True    False\n\nCompare to a DataFrame of different shape.\n\n>>> other = pd.DataFrame({'revenue': [300, 250, 100, 150]},\n...                      index=['A', 'B', 'C', 'D'])\n>>> other\n   revenue\nA      300\nB      250\nC      100\nD      150\n\n>>> df.gt(other)\n    cost  revenue\nA  False    False\nB  False    False\nC  False     True\nD  False    False\n\nCompare to a MultiIndex by level.\n\n>>> df_multindex = pd.DataFrame({'cost': [250, 150, 100, 150, 300, 220],\n...                              'revenue': [100, 250, 300, 200, 175, 225]},\n...                             index=[['Q1', 'Q1', 'Q1', 'Q2', 'Q2', 'Q2'],\n...                                    ['A', 'B', 'C', 'A', 'B', 'C']])\n>>> df_multindex\n      cost  revenue\nQ1 A   250      100\n   B   150      250\n   C   100      300\nQ2 A   150      200\n   B   300      175\n   C   220      225\n\n>>> df.le(df_multindex, level=1)\n       cost  revenue\nQ1 A   True     True\n   B   True     True\n   C   True     True\nQ2 A  False     True\n   B   True    False\n   C   True    False",
    "imports": [
        "import pandas",
        "import pandas as pd",
        "import numpy",
        "import numpy as np",
        "from pandas import DataFrame",
        "from enum import Enum",
        "from typing import List, Union, Tuple, Dict",
        "from pandas._typing import Axis"
    ],
    "return_type_hint": "-> DataFrame",
    "source_code": "    @Appender(ops.make_flex_doc(\"eq\", \"dataframe\"))\n    def eq(self, other, axis: Axis = \"columns\", level=None) -> DataFrame:\n        return self._flex_cmp_method(other, operator.eq, axis=axis, level=level)\n",
    "summarized_doc": "The provided Python function is a method that can be called on a DataFrame object. The method compares the values of the DataFrame to another value, and returns a DataFrame of boolean values representing whether each element is equal to the other value.\n\nThe method can compare a DataFrame to a scalar, sequence, Series, or another DataFrame. The level of comparison can be adjusted by specifying the axis and the level. Axis can be 0 or 'index' to compare by index, or 1 or 'columns' to compare by columns. Level allows you to match index values on the specified MultiIndex level. This function returns a DataFrame of boolean values, where True represents that the elements are equal and False represents that they are not.\n\nThe important thing to remember, is that mismatched indices will be combined together, and `NaN` values are considered different (i.e. `NaN` != `NaN`).\n\nExample usage:\n```\ndf = pd.DataFrame({'cost': [250, 150, 100],\n                   'revenue': [100, 250, 300]},\n                  index=['A', 'B', 'C'])\n\nprint(df.eq(100))\n```\nThis will compare every element in the DataFrame to 100 and output a DataFrame of booleans. \n\nIn addition, this functionality includes equivalent methods for all comparison operators (`==`, `!=`, `<=`, `<`, `>=`, `>`), allowing you to compare DataFrames for equality, inequality, less than, greater than, and their inclusive versions."
}