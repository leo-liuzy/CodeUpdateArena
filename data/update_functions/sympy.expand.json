{
    "api_path": "sympy.expand",
    "arguments_str": "e,deep=True,modulus=None,power_base=True,power_exp=True,mul=True,log=True,multinomial=True,basic=True,**hints",
    "doc_string": "Expand an expression using methods given as hints.\n\nExplanation\n===========\n\nHints evaluated unless explicitly set to False are:  ``basic``, ``log``,\n``multinomial``, ``mul``, ``power_base``, and ``power_exp`` The following\nhints are supported but not applied unless set to True:  ``complex``,\n``func``, and ``trig``.  In addition, the following meta-hints are\nsupported by some or all of the other hints:  ``frac``, ``numer``,\n``denom``, ``modulus``, and ``force``.  ``deep`` is supported by all\nhints.  Additionally, subclasses of Expr may define their own hints or\nmeta-hints.\n\nThe ``basic`` hint is used for any special rewriting of an object that\nshould be done automatically (along with the other hints like ``mul``)\nwhen expand is called. This is a catch-all hint to handle any sort of\nexpansion that may not be described by the existing hint names. To use\nthis hint an object should override the ``_eval_expand_basic`` method.\nObjects may also define their own expand methods, which are not run by\ndefault.  See the API section below.\n\nIf ``deep`` is set to ``True`` (the default), things like arguments of\nfunctions are recursively expanded.  Use ``deep=False`` to only expand on\nthe top level.\n\nIf the ``force`` hint is used, assumptions about variables will be ignored\nin making the expansion.\n\nHints\n=====\n\nThese hints are run by default\n\nmul\n---\n\nDistributes multiplication over addition:\n\n>>> from sympy import cos, exp, sin\n>>> from sympy.abc import x, y, z\n>>> (y*(x + z)).expand(mul=True)\nx*y + y*z\n\nmultinomial\n-----------\n\nExpand (x + y + ...)**n where n is a positive integer.\n\n>>> ((x + y + z)**2).expand(multinomial=True)\nx**2 + 2*x*y + 2*x*z + y**2 + 2*y*z + z**2\n\npower_exp\n---------\n\nExpand addition in exponents into multiplied bases.\n\n>>> exp(x + y).expand(power_exp=True)\nexp(x)*exp(y)\n>>> (2**(x + y)).expand(power_exp=True)\n2**x*2**y\n\npower_base\n----------\n\nSplit powers of multiplied bases.\n\nThis only happens by default if assumptions allow, or if the\n``force`` meta-hint is used:\n\n>>> ((x*y)**z).expand(power_base=True)\n(x*y)**z\n>>> ((x*y)**z).expand(power_base=True, force=True)\nx**z*y**z\n>>> ((2*y)**z).expand(power_base=True)\n2**z*y**z\n\nNote that in some cases where this expansion always holds, SymPy performs\nit automatically:\n\n>>> (x*y)**2\nx**2*y**2\n\nlog\n---\n\nPull out power of an argument as a coefficient and split logs products\ninto sums of logs.\n\nNote that these only work if the arguments of the log function have the\nproper assumptions--the arguments must be positive and the exponents must\nbe real--or else the ``force`` hint must be True:\n\n>>> from sympy import log, symbols\n>>> log(x**2*y).expand(log=True)\nlog(x**2*y)\n>>> log(x**2*y).expand(log=True, force=True)\n2*log(x) + log(y)\n>>> x, y = symbols('x,y', positive=True)\n>>> log(x**2*y).expand(log=True)\n2*log(x) + log(y)\n\nbasic\n-----\n\nThis hint is intended primarily as a way for custom subclasses to enable\nexpansion by default.\n\nThese hints are not run by default:\n\ncomplex\n-------\n\nSplit an expression into real and imaginary parts.\n\n>>> x, y = symbols('x,y')\n>>> (x + y).expand(complex=True)\nre(x) + re(y) + I*im(x) + I*im(y)\n>>> cos(x).expand(complex=True)\n-I*sin(re(x))*sinh(im(x)) + cos(re(x))*cosh(im(x))\n\nNote that this is just a wrapper around ``as_real_imag()``.  Most objects\nthat wish to redefine ``_eval_expand_complex()`` should consider\nredefining ``as_real_imag()`` instead.\n\nfunc\n----\n\nExpand other functions.\n\n>>> from sympy import gamma\n>>> gamma(x + 1).expand(func=True)\nx*gamma(x)\n\ntrig\n----\n\nDo trigonometric expansions.\n\n>>> cos(x + y).expand(trig=True)\n-sin(x)*sin(y) + cos(x)*cos(y)\n>>> sin(2*x).expand(trig=True)\n2*sin(x)*cos(x)\n\nNote that the forms of ``sin(n*x)`` and ``cos(n*x)`` in terms of ``sin(x)``\nand ``cos(x)`` are not unique, due to the identity `\\sin^2(x) + \\cos^2(x)\n= 1`.  The current implementation uses the form obtained from Chebyshev\npolynomials, but this may change.  See `this MathWorld article\n<https://mathworld.wolfram.com/Multiple-AngleFormulas.html>`_ for more\ninformation.\n\nNotes\n=====\n\n- You can shut off unwanted methods::\n\n    >>> (exp(x + y)*(x + y)).expand()\n    x*exp(x)*exp(y) + y*exp(x)*exp(y)\n    >>> (exp(x + y)*(x + y)).expand(power_exp=False)\n    x*exp(x + y) + y*exp(x + y)\n    >>> (exp(x + y)*(x + y)).expand(mul=False)\n    (x + y)*exp(x)*exp(y)\n\n- Use deep=False to only expand on the top level::\n\n    >>> exp(x + exp(x + y)).expand()\n    exp(x)*exp(exp(x)*exp(y))\n    >>> exp(x + exp(x + y)).expand(deep=False)\n    exp(x)*exp(exp(x + y))\n\n- Hints are applied in an arbitrary, but consistent order (in the current\n  implementation, they are applied in alphabetical order, except\n  multinomial comes before mul, but this may change).  Because of this,\n  some hints may prevent expansion by other hints if they are applied\n  first. For example, ``mul`` may distribute multiplications and prevent\n  ``log`` and ``power_base`` from expanding them. Also, if ``mul`` is\n  applied before ``multinomial`, the expression might not be fully\n  distributed. The solution is to use the various ``expand_hint`` helper\n  functions or to use ``hint=False`` to this function to finely control\n  which hints are applied. Here are some examples::\n\n    >>> from sympy import expand, expand_mul, expand_power_base\n    >>> x, y, z = symbols('x,y,z', positive=True)\n\n    >>> expand(log(x*(y + z)))\n    log(x) + log(y + z)\n\n  Here, we see that ``log`` was applied before ``mul``.  To get the mul\n  expanded form, either of the following will work::\n\n    >>> expand_mul(log(x*(y + z)))\n    log(x*y + x*z)\n    >>> expand(log(x*(y + z)), log=False)\n    log(x*y + x*z)\n\n  A similar thing can happen with the ``power_base`` hint::\n\n    >>> expand((x*(y + z))**x)\n    (x*y + x*z)**x\n\n  To get the ``power_base`` expanded form, either of the following will\n  work::\n\n    >>> expand((x*(y + z))**x, mul=False)\n    x**x*(y + z)**x\n    >>> expand_power_base((x*(y + z))**x)\n    x**x*(y + z)**x\n\n    >>> expand((x + y)*y/x)\n    y + y**2/x\n\n  The parts of a rational expression can be targeted::\n\n    >>> expand((x + y)*y/x/(x + 1), frac=True)\n    (x*y + y**2)/(x**2 + x)\n    >>> expand((x + y)*y/x/(x + 1), numer=True)\n    (x*y + y**2)/(x*(x + 1))\n    >>> expand((x + y)*y/x/(x + 1), denom=True)\n    y*(x + y)/(x**2 + x)\n\n- The ``modulus`` meta-hint can be used to reduce the coefficients of an\n  expression post-expansion::\n\n    >>> expand((3*x + 1)**2)\n    9*x**2 + 6*x + 1\n    >>> expand((3*x + 1)**2, modulus=5)\n    4*x**2 + x + 1\n\n- Either ``expand()`` the function or ``.expand()`` the method can be\n  used.  Both are equivalent::\n\n    >>> expand((x + 1)**2)\n    x**2 + 2*x + 1\n    >>> ((x + 1)**2).expand()\n    x**2 + 2*x + 1\n\nAPI\n===\n\nObjects can define their own expand hints by defining\n``_eval_expand_hint()``.  The function should take the form::\n\n    def _eval_expand_hint(self, **hints):\n        # Only apply the method to the top-level expression\n        ...\n\nSee also the example below.  Objects should define ``_eval_expand_hint()``\nmethods only if ``hint`` applies to that specific object.  The generic\n``_eval_expand_hint()`` method defined in Expr will handle the no-op case.\n\nEach hint should be responsible for expanding that hint only.\nFurthermore, the expansion should be applied to the top-level expression\nonly.  ``expand()`` takes care of the recursion that happens when\n``deep=True``.\n\nYou should only call ``_eval_expand_hint()`` methods directly if you are\n100% sure that the object has the method, as otherwise you are liable to\nget unexpected ``AttributeError``s.  Note, again, that you do not need to\nrecursively apply the hint to args of your object: this is handled\nautomatically by ``expand()``.  ``_eval_expand_hint()`` should\ngenerally not be used at all outside of an ``_eval_expand_hint()`` method.\nIf you want to apply a specific expansion from within another method, use\nthe public ``expand()`` function, method, or ``expand_hint()`` functions.\n\nIn order for expand to work, objects must be rebuildable by their args,\ni.e., ``obj.func(*obj.args) == obj`` must hold.\n\nExpand methods are passed ``**hints`` so that expand hints may use\n'metahints'--hints that control how different expand methods are applied.\nFor example, the ``force=True`` hint described above that causes\n``expand(log=True)`` to ignore assumptions is such a metahint.  The\n``deep`` meta-hint is handled exclusively by ``expand()`` and is not\npassed to ``_eval_expand_hint()`` methods.\n\nNote that expansion hints should generally be methods that perform some\nkind of 'expansion'.  For hints that simply rewrite an expression, use the\n.rewrite() API.\n\nExamples\n========\n\n>>> from sympy import Expr, sympify\n>>> class MyClass(Expr):\n...     def __new__(cls, *args):\n...         args = sympify(args)\n...         return Expr.__new__(cls, *args)\n...\n...     def _eval_expand_double(self, *, force=False, **hints):\n...         '''\n...         Doubles the args of MyClass.\n...\n...         If there more than four args, doubling is not performed,\n...         unless force=True is also used (False by default).\n...         '''\n...         if not force and len(self.args) > 4:\n...             return self\n...         return self.func(*(self.args + self.args))\n...\n>>> a = MyClass(1, 2, MyClass(3, 4))\n>>> a\nMyClass(1, 2, MyClass(3, 4))\n>>> a.expand(double=True)\nMyClass(1, 2, MyClass(3, 4, 3, 4), 1, 2, MyClass(3, 4, 3, 4))\n>>> a.expand(double=True, deep=False)\nMyClass(1, 2, MyClass(3, 4), 1, 2, MyClass(3, 4))\n\n>>> b = MyClass(1, 2, 3, 4, 5)\n>>> b.expand(double=True)\nMyClass(1, 2, 3, 4, 5)\n>>> b.expand(double=True, force=True)\nMyClass(1, 2, 3, 4, 5, 1, 2, 3, 4, 5)\n\nSee Also\n========\n\nexpand_log, expand_mul, expand_multinomial, expand_complex, expand_trig,\nexpand_power_base, expand_power_exp, expand_func, sympy.simplify.hyperexpand.hyperexpand",
    "imports": [
        "import sympy"
    ],
    "return_type_hint": "",
    "source_code": "def expand(e, deep=True, modulus=None, power_base=True, power_exp=True,\n        mul=True, log=True, multinomial=True, basic=True, **hints):\n    r\"\"\"\n    Expand an expression using methods given as hints.\n\n    Explanation\n    ===========\n\n    Hints evaluated unless explicitly set to False are:  ``basic``, ``log``,\n    ``multinomial``, ``mul``, ``power_base``, and ``power_exp`` The following\n    hints are supported but not applied unless set to True:  ``complex``,\n    ``func``, and ``trig``.  In addition, the following meta-hints are\n    supported by some or all of the other hints:  ``frac``, ``numer``,\n    ``denom``, ``modulus``, and ``force``.  ``deep`` is supported by all\n    hints.  Additionally, subclasses of Expr may define their own hints or\n    meta-hints.\n\n    The ``basic`` hint is used for any special rewriting of an object that\n    should be done automatically (along with the other hints like ``mul``)\n    when expand is called. This is a catch-all hint to handle any sort of\n    expansion that may not be described by the existing hint names. To use\n    this hint an object should override the ``_eval_expand_basic`` method.\n    Objects may also define their own expand methods, which are not run by\n    default.  See the API section below.\n\n    If ``deep`` is set to ``True`` (the default), things like arguments of\n    functions are recursively expanded.  Use ``deep=False`` to only expand on\n    the top level.\n\n    If the ``force`` hint is used, assumptions about variables will be ignored\n    in making the expansion.\n\n    Hints\n    =====\n\n    These hints are run by default\n\n    mul\n    ---\n\n    Distributes multiplication over addition:\n\n    >>> from sympy import cos, exp, sin\n    >>> from sympy.abc import x, y, z\n    >>> (y*(x + z)).expand(mul=True)\n    x*y + y*z\n\n    multinomial\n    -----------\n\n    Expand (x + y + ...)**n where n is a positive integer.\n\n    >>> ((x + y + z)**2).expand(multinomial=True)\n    x**2 + 2*x*y + 2*x*z + y**2 + 2*y*z + z**2\n\n    power_exp\n    ---------\n\n    Expand addition in exponents into multiplied bases.\n\n    >>> exp(x + y).expand(power_exp=True)\n    exp(x)*exp(y)\n    >>> (2**(x + y)).expand(power_exp=True)\n    2**x*2**y\n\n    power_base\n    ----------\n\n    Split powers of multiplied bases.\n\n    This only happens by default if assumptions allow, or if the\n    ``force`` meta-hint is used:\n\n    >>> ((x*y)**z).expand(power_base=True)\n    (x*y)**z\n    >>> ((x*y)**z).expand(power_base=True, force=True)\n    x**z*y**z\n    >>> ((2*y)**z).expand(power_base=True)\n    2**z*y**z\n\n    Note that in some cases where this expansion always holds, SymPy performs\n    it automatically:\n\n    >>> (x*y)**2\n    x**2*y**2\n\n    log\n    ---\n\n    Pull out power of an argument as a coefficient and split logs products\n    into sums of logs.\n\n    Note that these only work if the arguments of the log function have the\n    proper assumptions--the arguments must be positive and the exponents must\n    be real--or else the ``force`` hint must be True:\n\n    >>> from sympy import log, symbols\n    >>> log(x**2*y).expand(log=True)\n    log(x**2*y)\n    >>> log(x**2*y).expand(log=True, force=True)\n    2*log(x) + log(y)\n    >>> x, y = symbols('x,y', positive=True)\n    >>> log(x**2*y).expand(log=True)\n    2*log(x) + log(y)\n\n    basic\n    -----\n\n    This hint is intended primarily as a way for custom subclasses to enable\n    expansion by default.\n\n    These hints are not run by default:\n\n    complex\n    -------\n\n    Split an expression into real and imaginary parts.\n\n    >>> x, y = symbols('x,y')\n    >>> (x + y).expand(complex=True)\n    re(x) + re(y) + I*im(x) + I*im(y)\n    >>> cos(x).expand(complex=True)\n    -I*sin(re(x))*sinh(im(x)) + cos(re(x))*cosh(im(x))\n\n    Note that this is just a wrapper around ``as_real_imag()``.  Most objects\n    that wish to redefine ``_eval_expand_complex()`` should consider\n    redefining ``as_real_imag()`` instead.\n\n    func\n    ----\n\n    Expand other functions.\n\n    >>> from sympy import gamma\n    >>> gamma(x + 1).expand(func=True)\n    x*gamma(x)\n\n    trig\n    ----\n\n    Do trigonometric expansions.\n\n    >>> cos(x + y).expand(trig=True)\n    -sin(x)*sin(y) + cos(x)*cos(y)\n    >>> sin(2*x).expand(trig=True)\n    2*sin(x)*cos(x)\n\n    Note that the forms of ``sin(n*x)`` and ``cos(n*x)`` in terms of ``sin(x)``\n    and ``cos(x)`` are not unique, due to the identity `\\sin^2(x) + \\cos^2(x)\n    = 1`.  The current implementation uses the form obtained from Chebyshev\n    polynomials, but this may change.  See `this MathWorld article\n    <https://mathworld.wolfram.com/Multiple-AngleFormulas.html>`_ for more\n    information.\n\n    Notes\n    =====\n\n    - You can shut off unwanted methods::\n\n        >>> (exp(x + y)*(x + y)).expand()\n        x*exp(x)*exp(y) + y*exp(x)*exp(y)\n        >>> (exp(x + y)*(x + y)).expand(power_exp=False)\n        x*exp(x + y) + y*exp(x + y)\n        >>> (exp(x + y)*(x + y)).expand(mul=False)\n        (x + y)*exp(x)*exp(y)\n\n    - Use deep=False to only expand on the top level::\n\n        >>> exp(x + exp(x + y)).expand()\n        exp(x)*exp(exp(x)*exp(y))\n        >>> exp(x + exp(x + y)).expand(deep=False)\n        exp(x)*exp(exp(x + y))\n\n    - Hints are applied in an arbitrary, but consistent order (in the current\n      implementation, they are applied in alphabetical order, except\n      multinomial comes before mul, but this may change).  Because of this,\n      some hints may prevent expansion by other hints if they are applied\n      first. For example, ``mul`` may distribute multiplications and prevent\n      ``log`` and ``power_base`` from expanding them. Also, if ``mul`` is\n      applied before ``multinomial`, the expression might not be fully\n      distributed. The solution is to use the various ``expand_hint`` helper\n      functions or to use ``hint=False`` to this function to finely control\n      which hints are applied. Here are some examples::\n\n        >>> from sympy import expand, expand_mul, expand_power_base\n        >>> x, y, z = symbols('x,y,z', positive=True)\n\n        >>> expand(log(x*(y + z)))\n        log(x) + log(y + z)\n\n      Here, we see that ``log`` was applied before ``mul``.  To get the mul\n      expanded form, either of the following will work::\n\n        >>> expand_mul(log(x*(y + z)))\n        log(x*y + x*z)\n        >>> expand(log(x*(y + z)), log=False)\n        log(x*y + x*z)\n\n      A similar thing can happen with the ``power_base`` hint::\n\n        >>> expand((x*(y + z))**x)\n        (x*y + x*z)**x\n\n      To get the ``power_base`` expanded form, either of the following will\n      work::\n\n        >>> expand((x*(y + z))**x, mul=False)\n        x**x*(y + z)**x\n        >>> expand_power_base((x*(y + z))**x)\n        x**x*(y + z)**x\n\n        >>> expand((x + y)*y/x)\n        y + y**2/x\n\n      The parts of a rational expression can be targeted::\n\n        >>> expand((x + y)*y/x/(x + 1), frac=True)\n        (x*y + y**2)/(x**2 + x)\n        >>> expand((x + y)*y/x/(x + 1), numer=True)\n        (x*y + y**2)/(x*(x + 1))\n        >>> expand((x + y)*y/x/(x + 1), denom=True)\n        y*(x + y)/(x**2 + x)\n\n    - The ``modulus`` meta-hint can be used to reduce the coefficients of an\n      expression post-expansion::\n\n        >>> expand((3*x + 1)**2)\n        9*x**2 + 6*x + 1\n        >>> expand((3*x + 1)**2, modulus=5)\n        4*x**2 + x + 1\n\n    - Either ``expand()`` the function or ``.expand()`` the method can be\n      used.  Both are equivalent::\n\n        >>> expand((x + 1)**2)\n        x**2 + 2*x + 1\n        >>> ((x + 1)**2).expand()\n        x**2 + 2*x + 1\n\n    API\n    ===\n\n    Objects can define their own expand hints by defining\n    ``_eval_expand_hint()``.  The function should take the form::\n\n        def _eval_expand_hint(self, **hints):\n            # Only apply the method to the top-level expression\n            ...\n\n    See also the example below.  Objects should define ``_eval_expand_hint()``\n    methods only if ``hint`` applies to that specific object.  The generic\n    ``_eval_expand_hint()`` method defined in Expr will handle the no-op case.\n\n    Each hint should be responsible for expanding that hint only.\n    Furthermore, the expansion should be applied to the top-level expression\n    only.  ``expand()`` takes care of the recursion that happens when\n    ``deep=True``.\n\n    You should only call ``_eval_expand_hint()`` methods directly if you are\n    100% sure that the object has the method, as otherwise you are liable to\n    get unexpected ``AttributeError``s.  Note, again, that you do not need to\n    recursively apply the hint to args of your object: this is handled\n    automatically by ``expand()``.  ``_eval_expand_hint()`` should\n    generally not be used at all outside of an ``_eval_expand_hint()`` method.\n    If you want to apply a specific expansion from within another method, use\n    the public ``expand()`` function, method, or ``expand_hint()`` functions.\n\n    In order for expand to work, objects must be rebuildable by their args,\n    i.e., ``obj.func(*obj.args) == obj`` must hold.\n\n    Expand methods are passed ``**hints`` so that expand hints may use\n    'metahints'--hints that control how different expand methods are applied.\n    For example, the ``force=True`` hint described above that causes\n    ``expand(log=True)`` to ignore assumptions is such a metahint.  The\n    ``deep`` meta-hint is handled exclusively by ``expand()`` and is not\n    passed to ``_eval_expand_hint()`` methods.\n\n    Note that expansion hints should generally be methods that perform some\n    kind of 'expansion'.  For hints that simply rewrite an expression, use the\n    .rewrite() API.\n\n    Examples\n    ========\n\n    >>> from sympy import Expr, sympify\n    >>> class MyClass(Expr):\n    ...     def __new__(cls, *args):\n    ...         args = sympify(args)\n    ...         return Expr.__new__(cls, *args)\n    ...\n    ...     def _eval_expand_double(self, *, force=False, **hints):\n    ...         '''\n    ...         Doubles the args of MyClass.\n    ...\n    ...         If there more than four args, doubling is not performed,\n    ...         unless force=True is also used (False by default).\n    ...         '''\n    ...         if not force and len(self.args) > 4:\n    ...             return self\n    ...         return self.func(*(self.args + self.args))\n    ...\n    >>> a = MyClass(1, 2, MyClass(3, 4))\n    >>> a\n    MyClass(1, 2, MyClass(3, 4))\n    >>> a.expand(double=True)\n    MyClass(1, 2, MyClass(3, 4, 3, 4), 1, 2, MyClass(3, 4, 3, 4))\n    >>> a.expand(double=True, deep=False)\n    MyClass(1, 2, MyClass(3, 4), 1, 2, MyClass(3, 4))\n\n    >>> b = MyClass(1, 2, 3, 4, 5)\n    >>> b.expand(double=True)\n    MyClass(1, 2, 3, 4, 5)\n    >>> b.expand(double=True, force=True)\n    MyClass(1, 2, 3, 4, 5, 1, 2, 3, 4, 5)\n\n    See Also\n    ========\n\n    expand_log, expand_mul, expand_multinomial, expand_complex, expand_trig,\n    expand_power_base, expand_power_exp, expand_func, sympy.simplify.hyperexpand.hyperexpand\n\n    \"\"\"\n    # don't modify this; modify the Expr.expand method\n    hints['power_base'] = power_base\n    hints['power_exp'] = power_exp\n    hints['mul'] = mul\n    hints['log'] = log\n    hints['multinomial'] = multinomial\n    hints['basic'] = basic\n    return sympify(e).expand(deep=deep, modulus=modulus, **hints)\n",
    "summarized_doc": "This is a Python function in the popular library, SymPy, for expanding mathematical expressions using predefined methods, which are referred to as 'hints'. There are multiple hints, such as `basic`, `log`, `multinomial`, `mul`, `power_base`, and `power_exp` that are evaluated by default, unless explicitly set to `False`. Additionally, there are hints such as `complex`, `func`, and `trig` that are supported but not applied unless set to `True`. \n\nThe function also supports meta-hints: `frac`, `numer`, `denom`, `modulus`, and `force`. The meta-hint `deep` is supported by all hints where if `deep` is set to `True` (the default), arguments of functions are recursively expanded. Use `deep=False` to only expand on the top level. If the `force` hint is used, assumptions about variables will be ignored in making the expansion.\n\nHere are brief descriptions and examples of some hints:\n\n- `mul`: Distributes multiplication over addition.\n    ```\n    >>> (y*(x + z)).expand(mul=True)\n    x*y + y*z\n    ```\n- `multinomial`: Expands `(x + y + ...)**n` where `n` is a positive integer.\n    ```\n    >>> ((x + y + z)**2).expand(multinomial=True)\n    x**2 + 2*x*y + 2*x*z + y**2 + 2*y*z + z**2\n    ```\n- `power_exp`: Expands addition in exponents into multiplied bases.\n    ```\n    >>> (2**(x + y)).expand(power_exp=True)\n    2**x*2**y\n    ```\n- `log`: Pulls out powers of arguments as coefficients and splits logs products into sums of logs, when arguments and exponents meet certain conditions.\n    ```\n    >>> log(x**2*y).expand(log=True, force=True)\n    2*log(x) + log(y)\n    ```\n\nObjects can define their own expand hints by defining `_eval_expand_hint()`. The function should take the form of:\n```\n    def _eval_expand_hint(self, **hints):\n        # Only apply the method to the top-level expression\n        ...\n```\nThe feature provides much flexibility and customization for mathematical expansion. For a more detailed explanation and examples of each hint, consult the original documentation."
}