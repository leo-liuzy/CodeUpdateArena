{
    "api_path": "numpy.cross",
    "arguments_str": "a,b,axisa=-1,axisb=-1,axisc=-1,axis=None",
    "doc_string": "Return the cross product of two (arrays of) vectors.\n\nThe cross product of `a` and `b` in :math:`R^3` is a vector perpendicular\nto both `a` and `b`.  If `a` and `b` are arrays of vectors, the vectors\nare defined by the last axis of `a` and `b` by default, and these axes\ncan have dimensions 2 or 3.  Where the dimension of either `a` or `b` is\n2, the third component of the input vector is assumed to be zero and the\ncross product calculated accordingly.  In cases where both input vectors\nhave dimension 2, the z-component of the cross product is returned.\n\nParameters\n----------\na : array_like\n    Components of the first vector(s).\nb : array_like\n    Components of the second vector(s).\naxisa : int, optional\n    Axis of `a` that defines the vector(s).  By default, the last axis.\naxisb : int, optional\n    Axis of `b` that defines the vector(s).  By default, the last axis.\naxisc : int, optional\n    Axis of `c` containing the cross product vector(s).  Ignored if\n    both input vectors have dimension 2, as the return is scalar.\n    By default, the last axis.\naxis : int, optional\n    If defined, the axis of `a`, `b` and `c` that defines the vector(s)\n    and cross product(s).  Overrides `axisa`, `axisb` and `axisc`.\n\nReturns\n-------\nc : ndarray\n    Vector cross product(s).\n\nRaises\n------\nValueError\n    When the dimension of the vector(s) in `a` and/or `b` does not\n    equal 2 or 3.\n\nSee Also\n--------\ninner : Inner product\nouter : Outer product.\nix_ : Construct index arrays.\n\nNotes\n-----\n.. versionadded:: 1.9.0\n\nSupports full broadcasting of the inputs.\n\nExamples\n--------\nVector cross-product.\n\n>>> x = [1, 2, 3]\n>>> y = [4, 5, 6]\n>>> np.cross(x, y)\narray([-3,  6, -3])\n\nOne vector with dimension 2.\n\n>>> x = [1, 2]\n>>> y = [4, 5, 6]\n>>> np.cross(x, y)\narray([12, -6, -3])\n\nEquivalently:\n\n>>> x = [1, 2, 0]\n>>> y = [4, 5, 6]\n>>> np.cross(x, y)\narray([12, -6, -3])\n\nBoth vectors with dimension 2.\n\n>>> x = [1,2]\n>>> y = [4,5]\n>>> np.cross(x, y)\narray(-3)\n\nMultiple vector cross-products. Note that the direction of the cross\nproduct vector is defined by the *right-hand rule*.\n\n>>> x = np.array([[1,2,3], [4,5,6]])\n>>> y = np.array([[4,5,6], [1,2,3]])\n>>> np.cross(x, y)\narray([[-3,  6, -3],\n       [ 3, -6,  3]])\n\nThe orientation of `c` can be changed using the `axisc` keyword.\n\n>>> np.cross(x, y, axisc=0)\narray([[-3,  3],\n       [ 6, -6],\n       [-3,  3]])\n\nChange the vector definition of `x` and `y` using `axisa` and `axisb`.\n\n>>> x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])\n>>> y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])\n>>> np.cross(x, y)\narray([[ -6,  12,  -6],\n       [  0,   0,   0],\n       [  6, -12,   6]])\n>>> np.cross(x, y, axisa=0, axisb=0)\narray([[-24,  48, -24],\n       [-30,  60, -30],\n       [-36,  72, -36]])",
    "imports": [
        "import numpy"
    ],
    "return_type_hint": "",
    "source_code": "@array_function_dispatch(_cross_dispatcher)\ndef cross(a, b, axisa=-1, axisb=-1, axisc=-1, axis=None):\n    \"\"\"\n    Return the cross product of two (arrays of) vectors.\n\n    The cross product of `a` and `b` in :math:`R^3` is a vector perpendicular\n    to both `a` and `b`.  If `a` and `b` are arrays of vectors, the vectors\n    are defined by the last axis of `a` and `b` by default, and these axes\n    can have dimensions 2 or 3.  Where the dimension of either `a` or `b` is\n    2, the third component of the input vector is assumed to be zero and the\n    cross product calculated accordingly.  In cases where both input vectors\n    have dimension 2, the z-component of the cross product is returned.\n\n    Parameters\n    ----------\n    a : array_like\n        Components of the first vector(s).\n    b : array_like\n        Components of the second vector(s).\n    axisa : int, optional\n        Axis of `a` that defines the vector(s).  By default, the last axis.\n    axisb : int, optional\n        Axis of `b` that defines the vector(s).  By default, the last axis.\n    axisc : int, optional\n        Axis of `c` containing the cross product vector(s).  Ignored if\n        both input vectors have dimension 2, as the return is scalar.\n        By default, the last axis.\n    axis : int, optional\n        If defined, the axis of `a`, `b` and `c` that defines the vector(s)\n        and cross product(s).  Overrides `axisa`, `axisb` and `axisc`.\n\n    Returns\n    -------\n    c : ndarray\n        Vector cross product(s).\n\n    Raises\n    ------\n    ValueError\n        When the dimension of the vector(s) in `a` and/or `b` does not\n        equal 2 or 3.\n\n    See Also\n    --------\n    inner : Inner product\n    outer : Outer product.\n    ix_ : Construct index arrays.\n\n    Notes\n    -----\n    .. versionadded:: 1.9.0\n\n    Supports full broadcasting of the inputs.\n\n    Examples\n    --------\n    Vector cross-product.\n\n    >>> x = [1, 2, 3]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([-3,  6, -3])\n\n    One vector with dimension 2.\n\n    >>> x = [1, 2]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([12, -6, -3])\n\n    Equivalently:\n\n    >>> x = [1, 2, 0]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([12, -6, -3])\n\n    Both vectors with dimension 2.\n\n    >>> x = [1,2]\n    >>> y = [4,5]\n    >>> np.cross(x, y)\n    array(-3)\n\n    Multiple vector cross-products. Note that the direction of the cross\n    product vector is defined by the *right-hand rule*.\n\n    >>> x = np.array([[1,2,3], [4,5,6]])\n    >>> y = np.array([[4,5,6], [1,2,3]])\n    >>> np.cross(x, y)\n    array([[-3,  6, -3],\n           [ 3, -6,  3]])\n\n    The orientation of `c` can be changed using the `axisc` keyword.\n\n    >>> np.cross(x, y, axisc=0)\n    array([[-3,  3],\n           [ 6, -6],\n           [-3,  3]])\n\n    Change the vector definition of `x` and `y` using `axisa` and `axisb`.\n\n    >>> x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])\n    >>> y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])\n    >>> np.cross(x, y)\n    array([[ -6,  12,  -6],\n           [  0,   0,   0],\n           [  6, -12,   6]])\n    >>> np.cross(x, y, axisa=0, axisb=0)\n    array([[-24,  48, -24],\n           [-30,  60, -30],\n           [-36,  72, -36]])\n\n    \"\"\"\n    if axis is not None:\n        axisa, axisb, axisc = (axis,) * 3\n    a = asarray(a)\n    b = asarray(b)\n    # Check axisa and axisb are within bounds\n    axisa = normalize_axis_index(axisa, a.ndim, msg_prefix='axisa')\n    axisb = normalize_axis_index(axisb, b.ndim, msg_prefix='axisb')\n\n    # Move working axis to the end of the shape\n    a = moveaxis(a, axisa, -1)\n    b = moveaxis(b, axisb, -1)\n    msg = (\"incompatible dimensions for cross product\\n\"\n           \"(dimension must be 2 or 3)\")\n    if a.shape[-1] not in (2, 3) or b.shape[-1] not in (2, 3):\n        raise ValueError(msg)\n\n    # Create the output array\n    shape = broadcast(a[..., 0], b[..., 0]).shape\n    if a.shape[-1] == 3 or b.shape[-1] == 3:\n        shape += (3,)\n        # Check axisc is within bounds\n        axisc = normalize_axis_index(axisc, len(shape), msg_prefix='axisc')\n    dtype = promote_types(a.dtype, b.dtype)\n    cp = empty(shape, dtype)\n\n    # recast arrays as dtype\n    a = a.astype(dtype)\n    b = b.astype(dtype)\n\n    # create local aliases for readability\n    a0 = a[..., 0]\n    a1 = a[..., 1]\n    if a.shape[-1] == 3:\n        a2 = a[..., 2]\n    b0 = b[..., 0]\n    b1 = b[..., 1]\n    if b.shape[-1] == 3:\n        b2 = b[..., 2]\n    if cp.ndim != 0 and cp.shape[-1] == 3:\n        cp0 = cp[..., 0]\n        cp1 = cp[..., 1]\n        cp2 = cp[..., 2]\n\n    if a.shape[-1] == 2:\n        if b.shape[-1] == 2:\n            # a0 * b1 - a1 * b0\n            multiply(a0, b1, out=cp)\n            cp -= a1 * b0\n            return cp\n        else:\n            assert b.shape[-1] == 3\n            # cp0 = a1 * b2 - 0  (a2 = 0)\n            # cp1 = 0 - a0 * b2  (a2 = 0)\n            # cp2 = a0 * b1 - a1 * b0\n            multiply(a1, b2, out=cp0)\n            multiply(a0, b2, out=cp1)\n            negative(cp1, out=cp1)\n            multiply(a0, b1, out=cp2)\n            cp2 -= a1 * b0\n    else:\n        assert a.shape[-1] == 3\n        if b.shape[-1] == 3:\n            # cp0 = a1 * b2 - a2 * b1\n            # cp1 = a2 * b0 - a0 * b2\n            # cp2 = a0 * b1 - a1 * b0\n            multiply(a1, b2, out=cp0)\n            tmp = array(a2 * b1)\n            cp0 -= tmp\n            multiply(a2, b0, out=cp1)\n            multiply(a0, b2, out=tmp)\n            cp1 -= tmp\n            multiply(a0, b1, out=cp2)\n            multiply(a1, b0, out=tmp)\n            cp2 -= tmp\n        else:\n            assert b.shape[-1] == 2\n            # cp0 = 0 - a2 * b1  (b2 = 0)\n            # cp1 = a2 * b0 - 0  (b2 = 0)\n            # cp2 = a0 * b1 - a1 * b0\n            multiply(a2, b1, out=cp0)\n            negative(cp0, out=cp0)\n            multiply(a2, b0, out=cp1)\n            multiply(a0, b1, out=cp2)\n            cp2 -= a1 * b0\n\n    return moveaxis(cp, -1, axisc)\n",
    "summarized_doc": "This function returns the cross product of two vectors or arrays of vectors `a` and `b`. In `R^3`, the cross product is a vector perpendicular to both `a` and `b`. If `a` and `b` are arrays of vectors, the vectors are defined by their last axis by default which can have dimensions 2 or 3. The assumption is that the third component of the vector where dimension of either `a` or `b` is 2, will be zero and the cross product will be calculated accordingly. The cross product returns the z-component in cases where both input vectors have dimension 2.\n\n**Parameters:**\n\n- `a` (array_like) : Components of the first vector(s).\n- `b` (array_like) : Components of the second vector(s).\n- `axisa` (int, optional) : Axis of `a` that defines the vector(s). By default, the last axis.\n- `axisb` (int, optional) : Axis of `b` that defines the vector(s). By default, the last axis.\n- `axisc` (int, optional) : Axis of `c` containing the cross product vector(s), it's ignored if both input vectors have dimension 2 as the return is scalar. By default, the last axis.\n- `axis` (int, optional) : If defined, the axis of `a`, `b` and `c` that defines the vector(s) and cross product(s). This overrides `axisa`, `axisb` and `axisc`.\n\n**Returns:**\n\n- `c` (ndarray) : Vector cross product(s).\n\nA ValueError is raised when the dimension of the vector(s) in `a` and/or `b` does not equal 2 or 3.\n\n**Example:**\n\n```python\nimport numpy as np\nx = [1, 2, 3]\ny = [4, 5, 6]\nnp.cross(x, y)\n```\n\n**Output:**\n\n```shell\narray([-3, 6, -3])\n```\nThis function has been available since version 1.9.0 and supports full broadcasting of the inputs."
}